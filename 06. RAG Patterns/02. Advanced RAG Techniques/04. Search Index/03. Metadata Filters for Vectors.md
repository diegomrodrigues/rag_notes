## Indexa√ß√£o Sem√¢ntica com Filtragem de Metadados e Indexa√ß√£o Hier√°rquica

### Introdu√ß√£o

A efic√°cia dos sistemas de Recupera√ß√£o Aumentada por Gera√ß√£o (RAG) depende crucialmente da capacidade de recuperar informa√ß√µes relevantes de maneira eficiente. Expandindo sobre os conceitos de indexa√ß√£o sem√¢ntica, este cap√≠tulo explora t√©cnicas avan√ßadas para otimizar a busca e recupera√ß√£o de documentos, com foco na utiliza√ß√£o de metadados e indexa√ß√£o hier√°rquica. A integra√ß√£o de metadados nos √≠ndices vetoriais permite refinar as buscas, considerando atributos espec√≠ficos dos dados, enquanto a indexa√ß√£o hier√°rquica visa melhorar a escalabilidade e a efici√™ncia em grandes bases de dados.

### Conceitos Fundamentais

#### Filtragem por Metadados

A **filtragem por metadados** enriquece a busca vetorial ao permitir que o sistema considere atributos associados aos documentos, al√©m do seu conte√∫do sem√¢ntico [^1]. Em vez de depender unicamente da similaridade vetorial, podemos restringir a busca a um subconjunto de documentos que atendam a crit√©rios espec√≠ficos. Por exemplo, podemos filtrar documentos por data de publica√ß√£o, fonte, autor, ou qualquer outra informa√ß√£o relevante.

A implementa√ß√£o da filtragem por metadados envolve os seguintes passos:

1.  **Extra√ß√£o de Metadados:** Identificar e extrair metadados relevantes de cada documento. Isso pode ser feito automaticamente (e.g., data de cria√ß√£o do arquivo) ou manualmente (e.g., tags atribu√≠das por um usu√°rio).
2.  **Associa√ß√£o com Vetores:** Associar os metadados extra√≠dos aos vetores correspondentes no √≠ndice vetorial. Cada entrada no √≠ndice conter√°, al√©m do vetor de embedding, um conjunto de pares chave-valor representando os metadados.
3.  **Defini√ß√£o de Filtros:** Formular consultas que especifiquem os crit√©rios de filtragem com base nos metadados. Por exemplo, "buscar documentos que contenham a palavra 'IA' e foram publicados ap√≥s 01/01/2023".
4.  **Aplica√ß√£o dos Filtros:** Durante a busca, aplicar os filtros aos metadados para selecionar apenas os documentos que atendem aos crit√©rios. Em seguida, realizar a busca vetorial no subconjunto filtrado.

> üí° **Exemplo Num√©rico:**
>
> Suponha que temos os seguintes documentos com seus respectivos metadados:
>
> | Documento | Conte√∫do                                    | Data de Publica√ß√£o | Autor        |
> | :-------- | :------------------------------------------ | :----------------- | :----------- |
> | Doc1      | "Intelig√™ncia Artificial e Machine Learning" | 01/01/2022         | Jo√£o Silva   |
> | Doc2      | "Aplica√ß√µes de IA na medicina"             | 15/05/2023         | Maria Souza  |
> | Doc3      | "Rob√≥tica e Automa√ß√£o com IA"             | 10/03/2023         | Pedro Oliveira |
> | Doc4      | "Deep Learning e Redes Neurais"              | 20/12/2021         | Ana Santos   |
>
> E a consulta √©: "Artigos sobre IA publicados em 2023".
>
> 1.  **Filtro de Metadados:**  `Data de Publica√ß√£o >= 01/01/2023 AND Data de Publica√ß√£o <= 31/12/2023`
>
> 2.  **Documentos Selecionados ap√≥s Filtragem:** Doc2 e Doc3
>
> 3.  **Busca Sem√¢ntica:** A busca vetorial seria realizada apenas em Doc2 e Doc3, em vez de todos os documentos, otimizando o processo. Isso √© crucial quando o n√∫mero de documentos √© muito grande.

A filtragem por metadados pode ser expressa formalmente da seguinte forma:

Seja $D$ o conjunto de todos os documentos indexados, e $M(d)$ o conjunto de metadados associados a um documento $d \in D$. Uma consulta $q$ com filtros de metadados √© definida como $q = (q_{sem}, q_{meta})$, onde $q_{sem}$ √© a parte sem√¢ntica da consulta e $q_{meta}$ √© o conjunto de filtros sobre os metadados.

A fun√ß√£o de busca $S(q, D)$ retorna o conjunto de documentos relevantes $R \subseteq D$ de acordo com a consulta $q$. Com a filtragem de metadados, essa fun√ß√£o pode ser decomposta em duas etapas:

1.  **Filtragem:** $D' = \{d \in D \mid q_{meta}(M(d)) = True\}$, onde $D'$ √© o subconjunto de documentos que satisfazem os filtros de metadados.
2.  **Busca Sem√¢ntica:** $R = S_{sem}(q_{sem}, D')$, onde $S_{sem}$ √© a fun√ß√£o de busca sem√¢ntica que opera sobre o subconjunto filtrado $D'$.

Essa abordagem permite uma busca mais precisa e direcionada, reduzindo o ru√≠do e aumentando a relev√¢ncia dos resultados.

**Teorema 1** A complexidade da busca com filtragem de metadados √© $O(f(n) + g(n'))$, onde $f(n)$ √© a complexidade da filtragem em um conjunto de $n$ documentos e $g(n')$ √© a complexidade da busca sem√¢ntica em um subconjunto de $n'$ documentos, com $n' \leq n$.

*Prova*: A filtragem por metadados requer a avalia√ß√£o dos filtros $q_{meta}$ para cada documento em $D$. A complexidade dessa etapa depende da natureza dos filtros e da estrutura dos metadados, denotada por $f(n)$. A busca sem√¢ntica √© ent√£o realizada apenas no subconjunto $D'$ de tamanho $n'$, com complexidade $g(n')$. A complexidade total √©, portanto, a soma das duas etapas. $\blacksquare$

**Corol√°rio 1** Se a filtragem de metadados tiver complexidade $O(n)$ e a busca sem√¢ntica tiver complexidade $O(log(n))$, ent√£o a complexidade da busca com filtragem de metadados ser√° $O(n + log(n'))$, onde $n' \leq n$.

> üí° **Exemplo Num√©rico:**
>
> Considerando o exemplo anterior com 1000 documentos ($n = 1000$).
>
> *   Filtragem de metadados leva tempo linear, $f(n) = n$.
> *   Busca sem√¢ntica (e.g., busca vetorial com um √≠ndice Annoy) tem complexidade logar√≠tmica, $g(n) = log(n)$.
>
> Se ap√≥s a filtragem, apenas 100 documentos ($n' = 100$) satisfazem os crit√©rios, a complexidade total seria:
>
> $O(1000 + log(100)) = O(1000 + 2) \approx O(1002)$.  Sem a filtragem, a complexidade seria $O(log(1000)) \approx O(3)$, por√©m com resultados possivelmente menos relevantes. No entanto, o ganho real vem da combina√ß√£o:  a filtragem *reduz o escopo* da busca sem√¢ntica, que se torna muito mais r√°pida e precisa.
>
> A import√¢ncia reside na redu√ß√£o dr√°stica do espa√ßo de busca, direcionando a busca sem√¢ntica para um conjunto menor de documentos *relevantes*, aumentando a efici√™ncia e a precis√£o.

A filtragem por metadados pode ser combinada com diferentes t√©cnicas de busca sem√¢ntica. Al√©m disso, diferentes tipos de filtros podem ser aplicados, como filtros booleanos, filtros de intervalo e filtros baseados em express√µes regulares.

#### Indexa√ß√£o Hier√°rquica

A **indexa√ß√£o hier√°rquica** √© uma t√©cnica que visa melhorar a efici√™ncia da busca em grandes bases de dados, dividindo o √≠ndice em m√∫ltiplos n√≠veis [^1]. A ideia principal √© realizar uma busca inicial em um n√≠vel superior, que cont√©m resumos ou representa√ß√µes mais compactas dos documentos, para identificar um subconjunto de documentos relevantes. Em seguida, uma busca mais detalhada √© realizada apenas nesse subconjunto, reduzindo a carga computacional total.

Uma arquitetura comum de indexa√ß√£o hier√°rquica envolve dois n√≠veis:

1.  **√çndice de Resumos:** Este √≠ndice cont√©m resumos ou representa√ß√µes agregadas dos documentos. Por exemplo, cada entrada pode representar um conjunto de documentos relacionados (e.g., um cap√≠tulo de um livro) e conter um resumo do conte√∫do desse conjunto.
2.  **√çndice de Chunks:** Este √≠ndice cont√©m os documentos originais divididos em chunks menores (e.g., par√°grafos ou se√ß√µes). Cada entrada corresponde a um chunk e cont√©m o vetor de embedding correspondente.

O processo de busca com indexa√ß√£o hier√°rquica √© o seguinte:

1.  **Busca no √çndice de Resumos:** A consulta inicial √© realizada no √≠ndice de resumos para identificar os conjuntos de documentos mais relevantes. Isso pode ser feito usando busca vetorial ou outras t√©cnicas de recupera√ß√£o de informa√ß√£o.
2.  **Sele√ß√£o de Chunks:** Para cada conjunto de documentos selecionado no passo anterior, realiza-se uma busca mais detalhada no √≠ndice de chunks, restringindo a busca aos chunks pertencentes a esse conjunto.
3.  **Ranking e Retorno:** Os chunks recuperados s√£o ent√£o ranqueados de acordo com sua relev√¢ncia em rela√ß√£o √† consulta, e os melhores resultados s√£o retornados ao usu√°rio.

> üí° **Exemplo Num√©rico:**
>
> Imagine uma base de dados com 10.000 documentos, organizados em 100 cap√≠tulos (conjuntos de documentos).
>
> 1.  **√çndice de Resumos:**  Cont√©m 100 resumos, um para cada cap√≠tulo.
> 2.  **√çndice de Chunks:** Cada cap√≠tulo √© dividido em 100 chunks, totalizando 10.000 chunks.
>
> Uma consulta √© feita: "Impacto da IA na ind√∫stria 4.0".
>
> 1.  **Busca no √çndice de Resumos:**  A busca no √≠ndice de resumos identifica 5 cap√≠tulos relevantes.
> 2.  **Busca no √çndice de Chunks:**  A busca √© realizada apenas nos 5 cap√≠tulos selecionados, totalizando 500 chunks (5 cap√≠tulos * 100 chunks/cap√≠tulo).
>
> Sem a indexa√ß√£o hier√°rquica, a busca vetorial seria realizada em 10.000 chunks. Com a indexa√ß√£o hier√°rquica, a busca √© realizada em apenas 500 chunks, reduzindo significativamente a carga computacional.

![Hierarchical index retrieval in RAG, showcasing a multi-stage approach for efficient document retrieval and information synthesis.](./../images/image9.png)

A indexa√ß√£o hier√°rquica pode ser modelada matematicamente da seguinte forma:

Seja $C = \{C_1, C_2, \ldots, C_n\}$ o conjunto de conjuntos de documentos (chunks), e $S(C_i)$ o resumo associado ao conjunto $C_i$. O √≠ndice de resumos cont√©m pares $(S(C_i), C_i)$. O √≠ndice de chunks cont√©m os vetores de embedding dos chunks individuais dentro de cada $C_i$.

A fun√ß√£o de busca hier√°rquica $H(q, D)$ pode ser expressa como:

1.  **Busca no √çndice de Resumos:** $C' = S_{res}(q, \{S(C_1), S(C_2), \ldots, S(C_n)\})$, onde $S_{res}$ √© a fun√ß√£o de busca no √≠ndice de resumos e $C'$ √© o conjunto de conjuntos de documentos selecionados.
2.  **Busca no √çndice de Chunks:** Para cada $C_i \in C'$, realizar $R_i = S_{chunk}(q, C_i)$, onde $S_{chunk}$ √© a fun√ß√£o de busca no √≠ndice de chunks e $R_i$ √© o conjunto de chunks relevantes dentro de $C_i$.
3.  **Uni√£o e Ranking:** $R = \bigcup_{C_i \in C'} R_i$, e os chunks em $R$ s√£o ranqueados de acordo com sua relev√¢ncia.

A vantagem da indexa√ß√£o hier√°rquica √© que ela reduz o n√∫mero de compara√ß√µes vetoriais necess√°rias, especialmente em grandes bases de dados. Ao filtrar os documentos em um n√≠vel superior, evitamos realizar buscas detalhadas em documentos irrelevantes.

**Teorema 2** A complexidade da busca hier√°rquica √© $O(g(n) + \sum_{i \in C'} h(n_i))$, onde $g(n)$ √© a complexidade da busca no √≠ndice de resumos com $n$ conjuntos de documentos, $C'$ √© o conjunto de conjuntos de documentos selecionados e $h(n_i)$ √© a complexidade da busca no √≠ndice de chunks dentro do conjunto $C_i$ com $n_i$ chunks.

*Prova*: A busca hier√°rquica envolve duas etapas principais: a busca no √≠ndice de resumos e a busca nos √≠ndices de chunks dos conjuntos selecionados. A complexidade da busca no √≠ndice de resumos √© denotada por $g(n)$. Em seguida, para cada conjunto $C_i$ selecionado, √© realizada uma busca no √≠ndice de chunks correspondente, com complexidade $h(n_i)$. A complexidade total √©, portanto, a soma da complexidade da busca no √≠ndice de resumos e a soma das complexidades das buscas nos √≠ndices de chunks dos conjuntos selecionados. $\blacksquare$

**Lema 1** Se a busca no √≠ndice de resumos tiver complexidade $O(log(n))$ e a busca no √≠ndice de chunks tiver complexidade $O(log(m))$, onde $m$ √© o n√∫mero de chunks em cada conjunto, ent√£o a complexidade total da busca hier√°rquica ser√° $O(log(n) + |C'| * log(m))$, onde $|C'|$ √© o n√∫mero de conjuntos selecionados.

> üí° **Exemplo Num√©rico:**
>
> Retomando o exemplo anterior com 100 cap√≠tulos e 100 chunks por cap√≠tulo:
> *   $n = 100$ (n√∫mero de cap√≠tulos no √≠ndice de resumos)
> *   $m = 100$ (n√∫mero de chunks por cap√≠tulo)
> *   $|C'| = 5$ (n√∫mero de cap√≠tulos selecionados)
>
> Assumindo que a busca no √≠ndice de resumos e no √≠ndice de chunks t√™m complexidade $O(log(n))$ e $O(log(m))$, respectivamente:
>
> $O(log(100) + 5 * log(100)) = O(2 + 5 * 2) = O(12)$.  Comparado com $O(log(10000)) = O(4)$ de uma busca direta em todos os chunks, a hierarquia parece pior neste *caso espec√≠fico*.
>
> **Entretanto**:  A constante escondida por tr√°s da nota√ß√£o $O(.)$ importa!  A busca vetorial completa compara vetores *muito mais vezes* do que a busca no √≠ndice de resumos, que usa representa√ß√µes mais compactas. Al√©m disso, se *apenas um cap√≠tulo* fosse relevante ($|C'| = 1$), a complexidade cairia para $O(log(100) + 1 * log(100)) = O(4)$, igualando a busca direta, *mas operando num espa√ßo de busca menor, refinado*.
>
> O ganho crucial da indexa√ß√£o hier√°rquica √© a redu√ß√£o da *quantidade de c√°lculos de similaridade vetorial*, que s√£o computacionalmente caros. Ela se torna *significativamente* mais vantajosa com bases de dados *extremamente grandes*, onde a busca em um √∫nico n√≠vel seria impratic√°vel.

Al√©m disso, a indexa√ß√£o hier√°rquica pode ser estendida para m√∫ltiplos n√≠veis, criando uma hierarquia de √≠ndices com diferentes n√≠veis de granularidade. Essa abordagem pode ser particularmente √∫til para bases de dados muito grandes, onde a busca em um √∫nico √≠ndice de resumos ainda seria computacionalmente cara.

### Conclus√£o

A filtragem por metadados e a indexa√ß√£o hier√°rquica s√£o t√©cnicas poderosas para otimizar a busca e recupera√ß√£o de informa√ß√µes em sistemas RAG. Ao integrar metadados aos √≠ndices vetoriais, podemos refinar as buscas e considerar atributos espec√≠ficos dos dados. A indexa√ß√£o hier√°rquica, por sua vez, melhora a escalabilidade e a efici√™ncia, especialmente em grandes bases de dados, ao dividir o √≠ndice em m√∫ltiplos n√≠veis e realizar buscas em etapas. A combina√ß√£o dessas t√©cnicas pode levar a sistemas RAG mais precisos, eficientes e escal√°veis.

### Refer√™ncias
[^1]: Informa√ß√µes fornecidas no contexto.
<!-- END -->